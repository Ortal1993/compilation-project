.decl edge(srcId:number, dstId:number, kind:symbol, label:symbol, type:symbol)
.input edge(filename="edges.facts", delimiter=",")

.decl vertex(nodeId:number, type:symbol, label:symbol)
.input vertex(filename="vertices.facts", delimiter=",")

.decl controlVertex(nodeId:number, label:symbol)
.decl dataVertex(nodeId:number, label:symbol)

controlVertex(nodeId, label) :- vertex(nodeId, "control", label).
dataVertex(nodeId, label) :- vertex(nodeId, "data", label).

.decl startVertex(nodeId:number)
.decl paramVertex(nodeId:number)
.decl loadVertex(nodeId:number)
.decl callVertex(nodeId:number)
.decl mergeVertex(nodeId:number)

startVertex(nodeId) :- controlVertex(nodeId, label), match("[0-9]+ \\x7c start (.*)", label).
paramVertex(nodeId) :- dataVertex(nodeId, label), match("[0-9]+ \\x7c param (.*)", label).
loadVertex(nodeId) :- controlVertex(nodeId, label), match("[0-9]+ \\x7c load", label).
callVertex(nodeId) :- controlVertex(nodeId, label), match("[0-9]+ \\x7c call", label).
mergeVertex(nodeId) :- controlVertex(nodeId, label), match("[0-9]+ \\x7c merge", label).

// TODO: need to add type checking for parameters so only array params would exist in this relation
.decl arrayParameterInFunction(functionNodeId:number, arrayParameterNodeId:number)
arrayParameterInFunction(functionNodeId, arrayParameterNodeId) :-
startVertex(functionNodeId), paramVertex(arrayParameterNodeId),
edge(arrayParameterNodeId, functionNodeId, "association", _, _).

.decl controlNeighbors(srcNodeId:number, dstNodeId:number)
controlNeighbors(srcNodeId, dstNodeId) :- edge(srcNodeId, dstNodeId, "control", _, _).

.decl arrayMethods(name:symbol, delta:number)
arrayMethods("push", 1).
arrayMethods("pop", -1).
arrayMethods("unshift", 1).
arrayMethods("shift", -1).

.decl arrayMethodCalling(arrayParameterNodeId:number,
                         callControlNodeId:number, 
                         delta:number)
arrayMethodCalling(arrayParameterNodeId, callControlNodeId, delta) :-
paramVertex(arrayParameterNodeId),
loadVertex(loadControl),
callVertex(callControlNodeId),
vertex(propertyNodeId, "data", propertyLable),
edge(arrayParameterNodeId, loadControl, "data", "object", _),
edge(propertyNodeId, loadControl, "data", "property", _),
edge(loadControl, callControlNodeId, "data", "callable", _),
arrayMethods(methodName, delta),
match(cat("[0-9]+ \\x7c #", methodName), propertyLable).

.decl incomingControlEdgesToVertex(controlNodeId:number, incomingControlEdges:number)
incomingControlEdgesToVertex(controlNodeId, incomingControlEdges) :-
controlVertex(controlNodeId, _),
incomingControlEdges = count : edge(_, controlNodeId, "control", _, _).

.decl deltasInMergeBranchs(mergeNodeId:number, arrayParameterNodeId:number, firstDelta:number, secondDelta:number)

deltasInMergeBranchs(mergeNodeId, arrayParameterNodeId, firstDelta, secondDelta) :-
mergeVertex(mergeNodeId),
incomingControlEdgesToVertex(mergeNodeId, 2),
controlNeighbors(firstNodeId, mergeNodeId),
controlNeighbors(secondNodeId, mergeNodeId),
firstNodeId != secondNodeId,
deltaInControlNodeIdAux(firstNodeId, arrayParameterNodeId, firstDelta),
deltaInControlNodeIdAux(secondNodeId, arrayParameterNodeId, secondDelta).

// to track cases where there is only one incoming edge into a merge vertex
deltasInMergeBranchs(mergeNodeId, arrayParameterNodeId, delta, delta) :-
mergeVertex(mergeNodeId),
incomingControlEdgesToVertex(mergeNodeId, 1),
controlNeighbors(previousNodeId, mergeNodeId),
deltaInControlNodeIdAux(previousNodeId, arrayParameterNodeId, delta).

.decl controlPath(srcNodeId:number, dstNodeId:number)

controlPath(srcNodeId, dstNodeId) :-
controlNeighbors(srcNodeId, dstNodeId).

controlPath(srcNodeId, dstNodeId) :-
controlPath(srcNodeId, otherNodeId),
controlPath(otherNodeId, dstNodeId).

.decl deltaInLastControlNodeId(functionNodeId:number, controlNodeId:number, arrayParameterNodeId:number, delta:number)
deltaInLastControlNodeId(functionNodeId, controlNodeId, arrayParameterNodeId, delta) :-
startVertex(functionNodeId),
controlPath(functionNodeId, controlNodeId),
!edge(controlNodeId, _, "control", _, _),
deltaInControlNodeId(controlNodeId, arrayParameterNodeId, delta).

.decl functionFinalDelta(functionNodeId:number, arrayParameterNodeId:number, delta:number)
.output functionFinalDelta(filename="function_final_delta.csv", delimiter=",")

functionFinalDelta(functionNodeId, arrayParameterNodeId, minDelta) :-
minDelta = min delta : deltaInLastControlNodeId(functionNodeId, _, arrayParameterNodeId, delta),
maxDelta = max delta : deltaInLastControlNodeId(functionNodeId, _, arrayParameterNodeId, delta),
deltaInLastControlNodeId(functionNodeId, _, arrayParameterNodeId, _),
minDelta = maxDelta.

functionFinalDelta(functionNodeId, arrayParameterNodeId, 999) :-
minDelta = min delta : deltaInLastControlNodeId(functionNodeId, _, arrayParameterNodeId, delta),
maxDelta = max delta : deltaInLastControlNodeId(functionNodeId, _, arrayParameterNodeId, delta),
deltaInLastControlNodeId(functionNodeId, _, arrayParameterNodeId, _),
minDelta != maxDelta.

// // catches function callings where the callee gets an array as a parameter
// // TODO: not supported yet because souffle detects a dependency cycle between relations
// .decl functionCallWithArrayAsArgument(callNodeId:number, arrayParameterNodeId:number, delta:number)
// .output functionCallWithArrayAsArgument(filename="functionCallWithArrayAsArgument.csv", delimiter=",")

// functionCallWithArrayAsArgument(callNodeId, arrayParameterNodeId, delta) :-
// callVertex(callNodeId),
// paramVertex(arrayParameterNodeId),
// edge(arrayParameterNodeId, callNodeId, "data", paramToCallLabel, _),
// "pos:" = substr(paramToCallLabel, 0, strlen("pos:")),
// arrayParameterPosition = substr(paramToCallLabel, strlen("pos:"), strlen(paramToCallLabel) - strlen("pos: ")),
// edge(callableSymbolNodeId, callNodeId, "data", "callable", _),
// edge(callableFunctionNodeId, callableSymbolNodeId, "association", "association", "association"),
// functionFinalDelta(callableFunctionNodeId, arrayParameterPosition, delta).

.decl deltaInControlNodeIdAux(controlNodeId:number, arrayParameterNodeId:number, delta:number)

// the delta is 0 for each parameter at the start vertex
deltaInControlNodeIdAux(controlNodeId, arrayParameterNodeId, 0) :- 
arrayParameterInFunction(controlNodeId, arrayParameterNodeId).

// if controlNodeId is a call vertex of one of the array methods
deltaInControlNodeIdAux(controlNodeId, arrayParameterNodeId, delta) :-
controlNeighbors(previousControlNodeId, controlNodeId),
deltaInControlNodeIdAux(previousControlNodeId, arrayParameterNodeId, previousDelta),
previousDelta != 999,
arrayMethodCalling(arrayParameterNodeId, controlNodeId, currDelta),
delta = previousDelta + currDelta.

// if controlNodeId is a call vertex of one of the array methods, and the previous delta is TOP, we want
// the current delta to be TOP also
deltaInControlNodeIdAux(controlNodeId, arrayParameterNodeId, 999) :-
controlNeighbors(previousControlNodeId, controlNodeId),
deltaInControlNodeIdAux(previousControlNodeId, arrayParameterNodeId, previousDelta),
previousDelta = 999,
arrayMethodCalling(arrayParameterNodeId, controlNodeId, _).

// a regular control vertex (not a merge vertex) which does nothing
deltaInControlNodeIdAux(controlNodeId, arrayParameterNodeId, previousDelta) :-
!mergeVertex(controlNodeId),
controlNeighbors(previousControlNodeId, controlNodeId),
deltaInControlNodeIdAux(previousControlNodeId, arrayParameterNodeId, previousDelta),
!arrayMethodCalling(arrayParameterNodeId, controlNodeId, _).
// // TODO: not supported yet because souffle detects a dependency cycle between relations
// !functionCallWithArrayAsArgument(controlNodeId, arrayParameterNodeId, _)

// // TODO: not supported yet because souffle detects a dependency cycle between relations
// // if controlNodeId is a function call which takes the array as an argument
// deltaInControlNodeIdAux(controlNodeId, arrayParameterNodeId, delta) :-
// controlNeighbors(previousControlNodeId, controlNodeId),
// deltaInControlNodeIdAux(previousControlNodeId, arrayParameterNodeId, previousDelta),
// functionCallWithArrayAsArgument(callNodeId, arrayParameterNodeId, currDelta),
// delta = previousDelta + currDelta.

// a merge vertex with two delta-identical branchs
deltaInControlNodeIdAux(controlNodeId, arrayParameterNodeId, trueDelta) :-
deltasInMergeBranchs(controlNodeId, arrayParameterNodeId, trueDelta, falseDelta),
trueDelta = falseDelta.

// a merge vertex with two delta-not-identical branchs
deltaInControlNodeIdAux(controlNodeId, arrayParameterNodeId, 999) :-
deltasInMergeBranchs(controlNodeId, arrayParameterNodeId, trueDelta, falseDelta),
trueDelta != falseDelta,
trueDelta > -500, falseDelta > -500. // trueDelta and falseDelta are probably both not B

deltaInControlNodeIdAux(controlNodeId, arrayParameterNodeId, falseDelta) :-
deltasInMergeBranchs(controlNodeId, arrayParameterNodeId, trueDelta, falseDelta),
trueDelta != falseDelta,
trueDelta <= -500. // trueDelta is probably B

deltaInControlNodeIdAux(controlNodeId, arrayParameterNodeId, trueDelta) :-
deltasInMergeBranchs(controlNodeId, arrayParameterNodeId, trueDelta, falseDelta),
trueDelta != falseDelta,
falseDelta <= -500. // falseDelta is probably B

// initialize every delta to B
deltaInControlNodeIdAux(controlNodeId, arrayParameterNodeId, -999) :- 
controlVertex(controlNodeId, _),
arrayParameterInFunction(functionNodeId, arrayParameterNodeId),
controlPath(functionNodeId, controlNodeId).

.decl deltaInControlNodeId(controlNodeId:number, arrayParameterNodeId:number, delta:number)
.output deltaInControlNodeId(filename="delta_in_control.csv", delimiter=",")

deltaInControlNodeId(controlNodeId, arrayParameterNodeId, delta) :-
deltaInControlNodeIdAux(controlNodeId, arrayParameterNodeId, _),
delta = max currDelta: deltaInControlNodeIdAux(controlNodeId, arrayParameterNodeId, currDelta).
